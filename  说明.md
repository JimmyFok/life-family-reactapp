# 生活这一家
> 使用react创建一个app

## 1、素材路径问题
> 因为基于webpack编译，所以本来的相对路径必须进行转译操作。原理请参考：http://www.ruanyifeng.com/blog/2015/05/require.html

- 在js组件环境下用`require('路径')`

亲测如果在类render(){}或者JSX中使用都会有问题。

- JSX行内样式必须是对象

直接写时  <div style={{height: 100px}}>

引入变量时,建议
const style = { height: 100px } 
<div style={style}>

- 注意style变量必须用驼峰法的样式名，值基本不是数字就是字符串吗，还有记得是逗号分割

## 打开jsx支持补全html标签的设置
软件设置中搜索emmet.includeLanguages，增加到用户设置中。增加内容如下
```js
"emmet.includeLanguages": {
    "javascript": "javascriptreact"
}
```
这样就可以畅快的写jsx了。


## 2、React-router最新版使用方法

https://reacttraining.com/react-router/web/guides/quick-start

更应该的是`react-router-dom`

参考如下：http://react-china.org/t/react-router4/15843

exact是精准的，所以 “/” 目录的应该是用到它。

## 3、map来实现v-for时，key不是props，所以需要另外增加这个

## 4、react中引用图片问题

### 方法一：
<img src={require('../img/xx.png')} alt="" />

### 方法二：
import search from '../img/search.png'
import user from '../img/user.png'

<img src={search} alt="" />
<img src={user} alt="" />

### 方法三：
<img src='http://localhost:3000/my-project/src/img/icon1.png' alt="" />

### 背景图片引用方法
const divStyle = {
  color: 'red',
  backgroundImage: 'url(' + imgUrl + ')',
  // 或者 background: `url${require("1.jpg")}`
};

function HelloWorldComponent() {
  return <div style={divStyle}>Hello World!</div>;
}

注意～～拼接的路径require居然不行。。。

```js
const baseUrl = "../assets/img/"
const adState = [
    {
        imgsrc: baseUrl + "home-ad-1.png",
        title: "【10月抢购预告】 荣耀乐檬大神爆款 惊爆价"
    },
    {
        imgsrc: baseUrl + "home-ad-2.png",
        title: "【劲爆开抢】 宝洁大礼包优惠前所未有"
    },
    {
        imgsrc: baseUrl + "home-ad-3.png",
        title: "【神价再现】 GOD PRICE 华丽上市"
    }
]
```

但是改成这样又可以了
```js
const baseUrl = "assets/img/"
const adState = [
    {
        imgsrc: require("../"+ baseUrl + "home-ad-1.png"),
        title: "【10月抢购预告】 荣耀乐檬大神爆款 惊爆价"
    },
    {
        imgsrc: require("../"+ baseUrl + "home-ad-2.png"),
        title: "【劲爆开抢】 宝洁大礼包优惠前所未有"
    },
    {
        imgsrc: require("../"+ baseUrl + "home-ad-3.png"),
        title: "【神价再现】 GOD PRICE 华丽上市"
    }
]
```
这应该是已经将路径当作是引入模块了。


### 5、引入了Font Awesome库
> https://fontawesome.com/how-to-use/on-the-web/using-with/react


1、安装模块
```js
npm i --save @fortawesome/fontawesome-svg-core
npm i --save @fortawesome/free-solid-svg-icons
npm i --save @fortawesome/react-fontawesome
```
2、在如下网站找到需要的图标名字，例如home，那么就用faHome

https://fontawesome.com/icons?d=gallery 这里查免费的图标

```js
// 组件内引用
import { FontAwesomeIcon } from '@fortawesome/react-fontawesome'
import { faHome } from '@fortawesome/free-solid-svg-icons'

...
<FontAwesomeIcon icon={faHome} />
...
```

6、react-router路由传参数
> 参考： https://blog.csdn.net/qq20004604/article/details/79440416

React路由取参数，有两种：
?a=1 ：这种属于 search 字符串，在 location.search 里取值；
/a/123 ：这种需要从 match.params里取值；
但无论哪种，路由获取到的值，是跳转后的那一刻的值，而不是实时更新的最新值。


ps: match.url能去url值

7、属性传值中如何传布尔值？
> 要不就是`{value.toString()}`来转换为字符串传进去。

但是真正需要传入的是布尔，所以我需要{{back}}来写。

## 5、React-Router 4.x 的教程
https://www.jianshu.com/p/bf6b45ce5bcc

嵌套路由的例子

```js
// 定义一个父级路由
const PrimaryLayout = props => {
  return (
    <div className="primary-layout">
      <PrimaryHeader />
      <main>
        <Switch>
          <Route path="/" exact component={HomePage} />
          <Route path="/users" component={UserSubLayout} />
          <Route path="/products" component={ProductSubLayout} />
          <Redirect to="/" />
        </Switch>
      </main>
    </div>
  )
}

// 定义一个子级路由
const UserSubLayout = () => (
  <div className="user-sub-layout">
    <aside>
      <UserNav />
    </aside>
    <div className="primary-content">
      <Switch>
        <Route path="/users" exact component={BrowseUsersPage} />
        <Route path="/users/:userId" component={UserProfilePage} />
      </Switch>
    </div>
  </div>
)

const BrowseUsersPage = () => <BrowseUserTable />
const UserProfilePage = props => <UserProfile userId={props.match.params.userId} />
```
<aside>事侧栏标签。
但是有个问题就是为什么父类要用return而子类的却可以不用呢？所以其实组件就是相当于函数。（其实后面优化就发现其实return都可以省略了。）

```js
// 用match的url来优化一下，通过传参的方式来操作。
const UserSubLayout = ({match}) => (
    <div className="user-sub-layout">
        <aside>
            <UserNav />
        </aside>
        <div className="primary-content">
            <Switch>
                <Route path={match.path} exact component={BrowseUserTable} />
                <Route path={`${match.path}/:userId`} component={UserProfilePage} />
            </Switch>
        </div>
    </div>
)

const UserProfilePage = ({match}) => <UserProfile userId={match.params.userId} />

// 以下是自己加的测试代码
const UserNav = () => (
    <div>User Nav</div>
)
const BrowseUserTable = ({match}) => (
    <ul>
        <li><Link to={`${match.path}/bob`}>Bob</Link></li>
        <li><Link to={`${match.path}/Tom`}>Tom</Link></li>
        <li><Link to={`${match.path}/Jack`}>Jack</Link></li>
    </ul>
)
const UserProfile = ({ userId }) => <div>User: {userId}</div>;

```

注意：例子中return是在{}里的，即()=>{return(写JSX)}，而如果不要{}可以直接()=>(写JSX)

而且路由的组件都必须大写字幕开头


## 7、全国行政区域
> 基于需要地区的api，所以找到了这个。

https://github.com/fengyuanchen/distpicker


Vue项目可以用这个
https://www.npmjs.com/package/v-distpicker

## 8、替换所有无用回车行去除

Ctrl+F 点替换，点最后的.*的符号，输入正则匹配`^\s*(?=\r?$)\n`替换就好

## 9、需要解决定位到城市的问题
> https://www.cnblogs.com/softidea/p/6946779.html

### 核心：http://www.cnblogs.com/penghuwan/p/6943260.html

- webpack.config.js中设置

这里需要恶补webpack的知识点了。

因为是基于create-react-app来创建的，所以需要改的是：

地址：`node_module/react-scripts/config/webpack.config.dev.js`

最后加入这个
```js
externals:{
    'BMap': 'BMap'
  }
```js

这样就可以引入BMap模块了，而且这个模块在打包时不会一起打包。

- 引入后按照官方百度的demo来做都可以了。
```
import React, { Component } from 'react';
import BMap  from 'BMap';
import './App.css';

class App extends Component {

  componentDidMount () {
    var map = new BMap.Map("mapContainer"); // 创建Map实例
    map.centerAndZoom(new BMap.Point(116.404, 39.915), 11); // 初始化地图,设置中心点坐标和地图级别
    map.addControl(new BMap.MapTypeControl()); //添加地图类型控件
    map.setCurrentCity("北京"); // 设置地图显示的城市 此项是必须设置的
    map.enableScrollWheelZoom(true); //开启鼠标滚轮缩放
  }

  render() {
    return (
      <div>
        <div className="mapContainer" id="mapContainer"></div>
      </div>
    );
  }
}

export default App; 

```

暂时还有一个问题：
Geolocation access has been blocked because of a Feature Policy applied to the current document.
chrome的安全警告。

baidu例子http://lbsyun.baidu.com/jsdemo.htm#i8_1
中的
```js
//关于状态码
	//BMAP_STATUS_SUCCESS	检索成功。对应数值“0”。
	//BMAP_STATUS_CITY_LIST	城市列表。对应数值“1”。
	//BMAP_STATUS_UNKNOWN_LOCATION	位置结果未知。对应数值“2”。
	//BMAP_STATUS_UNKNOWN_ROUTE	导航结果未知。对应数值“3”。
	//BMAP_STATUS_INVALID_KEY	非法密钥。对应数值“4”。
	//BMAP_STATUS_INVALID_REQUEST	非法请求。对应数值“5”。
	//BMAP_STATUS_PERMISSION_DENIED	没有权限。对应数值“6”。(自 1.1 新增)
	//BMAP_STATUS_SERVICE_UNAVAILABLE	服务不可用。对应数值“7”。(自 1.1 新增)
	//BMAP_STATUS_TIMEOUT	超时。对应数值“8”。(自 1.1 新增)
```
其中react中用不支持左方BMAP_STATUS_SUCCESS，所以改成对应数字即可。


## switch... case... 中的case后面的字符串问题

'-'和数字都会导致报错。


## map的时候可以直接不用参数2就可以直接用id来表示对应的数量

```js
<ul onClick={this.handleChange.bind(this, "city")} className = {this.state.show[1]}>
  {this.state.cities.map(city => (
    <li value={city} key={id++} index={id++}>{city}</li>
  ))}
</ul>
```

## 终于弄好关于定位和城市联动之间的问题

### 1、突破点：重新了解生命周期，根据更新的周期中的根据前后state的变化来决定是否要重新渲染。

### 2、接着因为baidumap是在dom渲染完才能获取，所以componentDidMount后，才能开始获取定位，接着通过更新数据的控制变化来重新渲染组件中的state。


## 父类建立显示和隐藏函数，通过将其中一个函数当作对象传给子类，通过子类的元素点击来调用

虽然是通过props传入，但是也是需要bind(this)才能有效，不然this的指向就会是全局而报错。


## 在加入事件阻止时的报错

错误信息为[Intervention] Unable to preventDefault inside passive event listener due to target being treated as passive.

解决方案为：https://www.jianshu.com/p/04bf173826aa

```js
// 阻止全局的文档的滚动
    document.addEventListener("touchstart", function(e){
        e.preventDefault()
    },{passive:false})
    
    document.addEventListener("touchmove", function(e){
        e.preventDefault()
    },{passive:false})

    ```

注意：最好应该是全局先禁用，再在组件中增加滚动

暂时不知道如何将监听的addEventListener中的第三个参数传入{passive:false}怎么改，所以最后用了这个写法

```js
stopEvent(e){
        // console.log(this)
        // console.log(e.currentTarget)
        e.currentTarget.addEventListener('touchmove',function(e){
            e.preventDefault()
        }, {passive:false})
        
    }
    
    render(){
        return (
            <div>
                {/* 这里放被尽头 */}  ∂
                {
                    this.state.show?(
                        <div onLoad={this.stopEvent.bind(this)}>
                            <Share cancel= {this.cancel.bind(this)} />
                            <Home/>
                        </div>)
                    :
                    <Home/>
                    }
                    <button onClick={this.show.bind(this)}>弹出分享</button>
            </div>
        )
    }
```

思路是通过元素加载事件就赋予对应的禁止滚动，保留按压事件传递。


### 组件渲染的时候可以
```js
<this.props.comp />
```
这样就可以传入组件来完成新的组件了。